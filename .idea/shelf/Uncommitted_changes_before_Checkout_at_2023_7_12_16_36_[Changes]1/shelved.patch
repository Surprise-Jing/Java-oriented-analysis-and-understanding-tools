Index: staticSlicer/src/main/java/com/nju/boot/slicer/DataFlowEquationSlicer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.nju.boot.slicer;\r\n\r\nimport com.github.javaparser.ast.body.CallableDeclaration;\r\nimport com.nju.boot.edges.Edge;\r\nimport com.nju.boot.graphs.Graphs;\r\nimport com.nju.boot.graphs.cfg.CFG;\r\nimport com.nju.boot.graphs.dependencegraph.CDG;\r\nimport com.nju.boot.nodes.GraphNode;\r\nimport com.nju.boot.util.GraphUtil;\r\n\r\nimport java.util.*;\r\n\r\npublic class DataFlowEquationSlicer extends  AbstractSlicer{\r\n    Graphs graphs;\r\n\r\n    CFG cfg;\r\n\r\n    CDG cdg;\r\n\r\n    /**R[C](i) represents related variables in node i for slicing criterion C, using for tracking data dependencies */\r\n    Map<GraphNode<?>, Set<String>> relevantVariables;\r\n\r\n    /**S[C] represents the result of slicing */\r\n    Set<GraphNode<?>> relevantStatements;\r\n\r\n    /**B[C] represents branch statements, using for tracking control dependencies, the sign to stop the iteration */\r\n    Set<GraphNode<?>> branchStatements;\r\n\r\n    public DataFlowEquationSlicer(String fileName) {\r\n        graphs = new Graphs(fileName);\r\n    }\r\n\r\n    public DataFlowEquationSlicer(Graphs graphs){\r\n        this.graphs = graphs;\r\n\r\n    }\r\n\r\n\r\n    public boolean isMarked(GraphNode<?> node){\r\n        return relevantStatements.contains(node);\r\n    }\r\n\r\n    void InitializeRC0(SlicerCriterion slicerCriterion){\r\n        relevantVariables = new HashMap<>();\r\n        Map<GraphNode<?>, Integer> visited = new HashMap<>();\r\n        for(GraphNode<?> node: cfg.vertexSet()){\r\n            relevantVariables.put(node, new HashSet<>());\r\n            visited.put(node, 0);\r\n        }\r\n        List<GraphNode<?>> nodes = new LinkedList<>(slicerCriterion.getNodes());\r\n        while(true)\r\n        {\r\n            if(nodes.isEmpty()){\r\n                break;\r\n            }\r\n            GraphNode<?> node = nodes.remove(0);\r\n            if(visited.get(node) > 2*cfg.inDegreeOf(node))\r\n                continue;\r\n            relevantVariables.get(node).addAll(getRC0(node, slicerCriterion));\r\n            for(Edge edge: cfg.incomingEdgesOf(node)){\r\n                GraphNode<?> src = cfg.getEdgeSource(edge);\r\n                nodes.add(src);\r\n            }\r\n            visited.put(node, visited.get(node)+1);\r\n        }\r\n    }\r\n\r\n    Set<String> getRC0(GraphNode<?> node, SlicerCriterion slicerCriterion){\r\n        if(slicerCriterion.getNodes().contains(node)){\r\n            return slicerCriterion.getVariable();\r\n        }\r\n        if(node.getId() == 0 || node.getId() == 1){\r\n            return new HashSet<>();\r\n        }\r\n        Set<String> result = new HashSet<>();\r\n        for(Edge edge: cfg.outgoingEdgesOf(node)){\r\n            GraphNode<?> target = cfg.getEdgeTarget(edge);\r\n            // USE(n), when there is a v in both DEF(n) and R[0][C](m)\r\n            Set<String> targetRC0;\r\n            if(target.getId() > node.getId()){\r\n                targetRC0 = relevantVariables.get(target);\r\n            }\r\n            else{\r\n                targetRC0 = getRC0(target, slicerCriterion);\r\n            }\r\n            if(!Collections.disjoint(targetRC0, node.getDefinedVariables())){\r\n                result.addAll(node.getUsedVariables());\r\n            }\r\n            // v is not in DEF(n) and v is in R[0][C](m)\r\n            for(String s: targetRC0){\r\n                if(!node.getDefinedVariables().contains(s)){\r\n                    result.add(s);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    void InitializeSC0(SlicerCriterion slicerCriterion){\r\n        relevantStatements = new HashSet<>();\r\n        for(Edge edge: cfg.edgeSet()){\r\n            GraphNode<?> src = cfg.getEdgeSource(edge);\r\n            GraphNode<?> target = cfg.getEdgeTarget(edge);\r\n            if(!Collections.disjoint(relevantVariables.get(target), src.getDefinedVariables())){\r\n                relevantStatements.add(src);\r\n            }\r\n        }\r\n    }\r\n    public Set<GraphNode<?>>slice(int lineNumber,String variableName){\r\n        CallableDeclaration<?> tarMethod = GraphUtil.findMethodByLineNumber(graphs.getCu(),lineNumber);\r\n        this.cfg = graphs.getCFG(tarMethod);\r\n        this.cdg = graphs.getCDG(tarMethod);\r\n        Set<String> variables = new HashSet<>();\r\n        variables.add(variableName);\r\n        return slice(new SlicerCriterion(variables,lineNumber,cfg));\r\n    }\r\n\r\n    public Set<GraphNode<?>> slice(SlicerCriterion slicerCriterion){\r\n        InitializeRC0(slicerCriterion);\r\n        InitializeSC0(slicerCriterion);\r\n        System.out.println(relevantVariables);\r\n        System.out.println(relevantStatements);\r\n        branchStatements = new HashSet<>();\r\n        int round = 0;\r\n        while(true){\r\n            System.out.println(round++);\r\n            System.out.println(branchStatements);\r\n            Set<GraphNode<?>> oldBranchStatements = new HashSet<>(branchStatements);\r\n            for(GraphNode<?> branch: cfg.vertexSet()) {\r\n                for (GraphNode<?> node : INFL(branch)) {\r\n                    if (relevantStatements.contains(node)) {\r\n                        branchStatements.add(branch);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if(branchStatements.equals(oldBranchStatements)){\r\n                break;\r\n            }\r\n            for(GraphNode<?> node: cfg.vertexSet()){\r\n               for(GraphNode<?> branch: branchStatements){\r\n                   relevantVariables.get(node).addAll(getRC0(node, new SlicerCriterion(branch, cfg)));\r\n               }\r\n            }\r\n            relevantStatements.clear();\r\n            for(Edge edge: cfg.edgeSet()){\r\n                GraphNode<?> src = cfg.getEdgeSource(edge);\r\n                GraphNode<?> target = cfg.getEdgeTarget(edge);\r\n                if(!Collections.disjoint(relevantVariables.get(target), src.getDefinedVariables())){\r\n                    relevantStatements.add(src);\r\n                }\r\n            }\r\n            relevantStatements.addAll(branchStatements);\r\n        }\r\n        //Slicing node use variables\r\n        for(GraphNode<?> node: slicerCriterion.getNodes()){\r\n            if(!Collections.disjoint(node.getDefinedVariables(), slicerCriterion.getVariable()) ||\r\n                    !Collections.disjoint(node.getUsedVariables(), slicerCriterion.getVariable())){\r\n                relevantStatements.add(node);\r\n            }\r\n        }\r\n        relevantStatements.add(cfg.getRootNode().get());\r\n        return relevantStatements;\r\n    }\r\n\r\n    Set<GraphNode<?>> INFL(GraphNode<?> node){\r\n        Set<GraphNode<?>> result = new HashSet<>();\r\n        if(cfg.outDegreeOf(node) < 2){\r\n            return result;\r\n        }\r\n        for(Edge edge:cdg.outgoingEdgesOf(node)){\r\n            result.add(cdg.getEdgeTarget(edge));\r\n        }\r\n        /*\r\n        DijkstraShortestPath<GraphNode<?>, Edge> dijkstraShortestPath = new DijkstraShortestPath<>(cfg);\r\n        for(Edge edge: cdg.outgoingEdgesOf(node)){\r\n            GraphNode<?> target = cdg.getEdgeTarget(edge);\r\n            List<GraphNode<?>> nodes = dijkstraShortestPath.getPath(node, target).getVertexList();\r\n            nodes.remove(target);\r\n            result.addAll(nodes);\r\n        }\r\n         */\r\n        System.out.println(node);\r\n        System.out.println(result);\r\n        return result;\r\n    }\r\n\r\n\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/staticSlicer/src/main/java/com/nju/boot/slicer/DataFlowEquationSlicer.java b/staticSlicer/src/main/java/com/nju/boot/slicer/DataFlowEquationSlicer.java
--- a/staticSlicer/src/main/java/com/nju/boot/slicer/DataFlowEquationSlicer.java	
+++ b/staticSlicer/src/main/java/com/nju/boot/slicer/DataFlowEquationSlicer.java	
@@ -32,7 +32,6 @@
 
     public DataFlowEquationSlicer(Graphs graphs){
         this.graphs = graphs;
-
     }
 
 
@@ -142,6 +141,7 @@
                    relevantVariables.get(node).addAll(getRC0(node, new SlicerCriterion(branch, cfg)));
                }
             }
+            System.out.println(relevantVariables);
             relevantStatements.clear();
             for(Edge edge: cfg.edgeSet()){
                 GraphNode<?> src = cfg.getEdgeSource(edge);
@@ -180,8 +180,8 @@
             result.addAll(nodes);
         }
          */
-        System.out.println(node);
-        System.out.println(result);
+        //System.out.println(node);
+        //System.out.println(result);
         return result;
     }
 
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectModuleManager\">\r\n    <modules>\r\n      <module fileurl=\"file://$PROJECT_DIR$/backend (1).iml\" filepath=\"$PROJECT_DIR$/backend (1).iml\" />\r\n      <module fileurl=\"file://$PROJECT_DIR$/staticSlicer/staticSlicer.iml\" filepath=\"$PROJECT_DIR$/staticSlicer/staticSlicer.iml\" />\r\n    </modules>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/modules.xml b/.idea/modules.xml
--- a/.idea/modules.xml	
+++ b/.idea/modules.xml	
@@ -3,7 +3,6 @@
   <component name="ProjectModuleManager">
     <modules>
       <module fileurl="file://$PROJECT_DIR$/backend (1).iml" filepath="$PROJECT_DIR$/backend (1).iml" />
-      <module fileurl="file://$PROJECT_DIR$/staticSlicer/staticSlicer.iml" filepath="$PROJECT_DIR$/staticSlicer/staticSlicer.iml" />
     </modules>
   </component>
 </project>
\ No newline at end of file
