Index: staticSlicer/src/main/java/com/nju/boot/slicer/DataFlowEquationSlicer.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.nju.boot.slicer;\r\n\r\nimport com.nju.boot.edges.Edge;\r\nimport com.nju.boot.graphs.augmented.ACFG;\r\nimport com.nju.boot.graphs.cfg.CFG;\r\nimport com.nju.boot.graphs.dependencegraph.CDG;\r\nimport com.nju.boot.graphs.dependencegraph.PDG;\r\nimport com.nju.boot.nodes.GraphNode;\r\nimport org.checkerframework.checker.units.qual.C;\r\n\r\nimport java.util.*;\r\n\r\npublic class DataFlowEquationSlicer {\r\n\r\n    CFG cfg;\r\n\r\n    CDG cdg;\r\n\r\n    /**R[C](i) represents related variables in node i for slicing criterion C, using for tracking data dependencies */\r\n    Map<GraphNode<?>, Set<String>> relevantVariables;\r\n\r\n    /**S[C] represents the result of slicing */\r\n    Set<GraphNode<?>> relevantStatements;\r\n\r\n    /**B[C] represents branch statements, using for tracking control dependencies, the sign to stop the iteration */\r\n    Set<GraphNode<?>> branchStatements;\r\n\r\n    public DataFlowEquationSlicer(ACFG cfg){\r\n        this.cfg = cfg;\r\n        assert cfg.isBuilt();\r\n        this.cdg = new CDG();\r\n        this.cdg.buildFromACFG(cfg);\r\n    }\r\n\r\n    public boolean isMarked(GraphNode<?> node){\r\n        return relevantStatements.contains(node);\r\n    }\r\n\r\n    void InitializeRC0(SlicerCriterion slicerCriterion){\r\n        relevantVariables = new HashMap<>();\r\n        Map<GraphNode<?>, Integer> visited = new HashMap<>();\r\n        for(GraphNode<?> node: cfg.vertexSet()){\r\n            relevantVariables.put(node, new HashSet<>());\r\n            visited.put(node, 0);\r\n        }\r\n        List<GraphNode<?>> nodes = new LinkedList<>(slicerCriterion.getNodes());\r\n        while(true)\r\n        {\r\n            if(nodes.isEmpty()){\r\n                break;\r\n            }\r\n            GraphNode<?> node = nodes.remove(0);\r\n            if(visited.get(node) > 2*cfg.inDegreeOf(node))\r\n                continue;\r\n            relevantVariables.get(node).addAll(getRC0(node, slicerCriterion));\r\n            for(Edge edge: cfg.incomingEdgesOf(node)){\r\n                GraphNode<?> src = cfg.getEdgeSource(edge);\r\n                nodes.add(src);\r\n            }\r\n            visited.put(node, visited.get(node)+1);\r\n        }\r\n    }\r\n\r\n    Set<String> getRC0(GraphNode<?> node, SlicerCriterion slicerCriterion){\r\n        if(slicerCriterion.getNodes().contains(node)){\r\n            return slicerCriterion.getVariable();\r\n        }\r\n        if(node.getId() == 0 || node.getId() == 1){\r\n            return new HashSet<>();\r\n        }\r\n        Set<String> result = new HashSet<>();\r\n        for(Edge edge: cfg.outgoingEdgesOf(node)){\r\n            GraphNode<?> target = cfg.getEdgeTarget(edge);\r\n            // USE(n), when there is a v in both DEF(n) and R[0][C](m)\r\n            Set<String> targetRC0;\r\n            if(target.getId() > node.getId()){\r\n                targetRC0 = relevantVariables.get(target);\r\n            }\r\n            else{\r\n                targetRC0 = getRC0(target, slicerCriterion);\r\n            }\r\n            if(!Collections.disjoint(targetRC0, node.getDefinedVariables())){\r\n                result.addAll(node.getUsedVariables());\r\n            }\r\n            // v is not in DEF(n) and v is in R[0][C](m)\r\n            for(String s: targetRC0){\r\n                if(!node.getDefinedVariables().contains(s)){\r\n                    result.add(s);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    void InitializeSC0(SlicerCriterion slicerCriterion){\r\n        relevantStatements = new HashSet<>();\r\n        for(Edge edge: cfg.edgeSet()){\r\n            GraphNode<?> src = cfg.getEdgeSource(edge);\r\n            GraphNode<?> target = cfg.getEdgeTarget(edge);\r\n            if(!Collections.disjoint(relevantVariables.get(target), src.getDefinedVariables())){\r\n                relevantStatements.add(src);\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public void slice(SlicerCriterion slicerCriterion){\r\n        InitializeRC0(slicerCriterion);\r\n        InitializeSC0(slicerCriterion);\r\n        System.out.println(relevantVariables);\r\n        System.out.println(relevantStatements);\r\n        branchStatements = new HashSet<>();\r\n        int round = 0;\r\n        while(true){\r\n            System.out.println(round++);\r\n            System.out.println(branchStatements);\r\n            Set<GraphNode<?>> oldBranchStatements = new HashSet<>(branchStatements);\r\n            for(GraphNode<?> branch: cfg.vertexSet()) {\r\n                for (GraphNode<?> node : INFL(branch)) {\r\n                    if (relevantStatements.contains(node)) {\r\n                        branchStatements.add(branch);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            if(branchStatements.equals(oldBranchStatements)){\r\n                break;\r\n            }\r\n            for(GraphNode<?> node: cfg.vertexSet()){\r\n               for(GraphNode<?> branch: branchStatements){\r\n                   relevantVariables.get(node).addAll(getRC0(node, new SlicerCriterion(branch, cfg)));\r\n               }\r\n            }\r\n            relevantStatements.clear();\r\n            for(Edge edge: cfg.edgeSet()){\r\n                GraphNode<?> src = cfg.getEdgeSource(edge);\r\n                GraphNode<?> target = cfg.getEdgeTarget(edge);\r\n                if(!Collections.disjoint(relevantVariables.get(target), src.getDefinedVariables())){\r\n                    relevantStatements.add(src);\r\n                }\r\n            }\r\n            relevantStatements.addAll(branchStatements);\r\n        }\r\n        //Slicing node use variables\r\n        for(GraphNode<?> node: slicerCriterion.getNodes()){\r\n            if(!Collections.disjoint(node.getDefinedVariables(), slicerCriterion.getVariable()) ||\r\n                    !Collections.disjoint(node.getUsedVariables(), slicerCriterion.getVariable())){\r\n                relevantStatements.add(node);\r\n            }\r\n        }\r\n    }\r\n\r\n    Set<GraphNode<?>> INFL(GraphNode<?> node){\r\n        Set<GraphNode<?>> result = new HashSet<>();\r\n        if(cfg.outDegreeOf(node) < 2){\r\n            return result;\r\n        }\r\n        for(Edge edge:cdg.outgoingEdgesOf(node)){\r\n            result.add(cdg.getEdgeTarget(edge));\r\n        }\r\n        /*\r\n        DijkstraShortestPath<GraphNode<?>, Edge> dijkstraShortestPath = new DijkstraShortestPath<>(cfg);\r\n        for(Edge edge: cdg.outgoingEdgesOf(node)){\r\n            GraphNode<?> target = cdg.getEdgeTarget(edge);\r\n            List<GraphNode<?>> nodes = dijkstraShortestPath.getPath(node, target).getVertexList();\r\n            nodes.remove(target);\r\n            result.addAll(nodes);\r\n        }\r\n         */\r\n        System.out.println(node);\r\n        System.out.println(result);\r\n        return result;\r\n    }\r\n\r\n\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/staticSlicer/src/main/java/com/nju/boot/slicer/DataFlowEquationSlicer.java b/staticSlicer/src/main/java/com/nju/boot/slicer/DataFlowEquationSlicer.java
--- a/staticSlicer/src/main/java/com/nju/boot/slicer/DataFlowEquationSlicer.java	(revision 1ac285b88d8ebb7103d45f673d4e88ee1d5a841c)
+++ b/staticSlicer/src/main/java/com/nju/boot/slicer/DataFlowEquationSlicer.java	(date 1689150982492)
@@ -1,16 +1,17 @@
 package com.nju.boot.slicer;
 
+import com.github.javaparser.ast.body.CallableDeclaration;
 import com.nju.boot.edges.Edge;
-import com.nju.boot.graphs.augmented.ACFG;
+import com.nju.boot.graphs.Graphs;
 import com.nju.boot.graphs.cfg.CFG;
 import com.nju.boot.graphs.dependencegraph.CDG;
-import com.nju.boot.graphs.dependencegraph.PDG;
 import com.nju.boot.nodes.GraphNode;
-import org.checkerframework.checker.units.qual.C;
+import com.nju.boot.util.GraphUtil;
 
 import java.util.*;
 
-public class DataFlowEquationSlicer {
+public class DataFlowEquationSlicer extends  AbstractSlicer{
+    Graphs graphs;
 
     CFG cfg;
 
@@ -25,12 +26,14 @@
     /**B[C] represents branch statements, using for tracking control dependencies, the sign to stop the iteration */
     Set<GraphNode<?>> branchStatements;
 
-    public DataFlowEquationSlicer(ACFG cfg){
-        this.cfg = cfg;
-        assert cfg.isBuilt();
-        this.cdg = new CDG();
-        this.cdg.buildFromACFG(cfg);
+    public DataFlowEquationSlicer(String fileName) {
+        graphs = new Graphs(fileName);
     }
+
+    public DataFlowEquationSlicer(Graphs graphs){
+        this.graphs = graphs;
+    }
+
 
     public boolean isMarked(GraphNode<?> node){
         return relevantStatements.contains(node);
@@ -102,9 +105,16 @@
             }
         }
     }
+    public Set<GraphNode<?>>slice(int lineNumber,String variableName){
+        CallableDeclaration<?> tarMethod = GraphUtil.findMethodByLineNumber(graphs.getCu(),lineNumber);
+        this.cfg = graphs.getCFG(tarMethod);
+        this.cdg = graphs.getCDG(tarMethod);
+        Set<String> variables = new HashSet<>();
+        variables.add(variableName);
+        return slice(new SlicerCriterion(variables,lineNumber,cfg));
+    }
 
-
-    public void slice(SlicerCriterion slicerCriterion){
+    public Set<GraphNode<?>> slice(SlicerCriterion slicerCriterion){
         InitializeRC0(slicerCriterion);
         InitializeSC0(slicerCriterion);
         System.out.println(relevantVariables);
@@ -131,6 +141,7 @@
                    relevantVariables.get(node).addAll(getRC0(node, new SlicerCriterion(branch, cfg)));
                }
             }
+            System.out.println(relevantVariables);
             relevantStatements.clear();
             for(Edge edge: cfg.edgeSet()){
                 GraphNode<?> src = cfg.getEdgeSource(edge);
@@ -148,6 +159,8 @@
                 relevantStatements.add(node);
             }
         }
+        relevantStatements.add(cfg.getRootNode().get());
+        return relevantStatements;
     }
 
     Set<GraphNode<?>> INFL(GraphNode<?> node){
@@ -167,8 +180,8 @@
             result.addAll(nodes);
         }
          */
-        System.out.println(node);
-        System.out.println(result);
+        //System.out.println(node);
+        //System.out.println(result);
         return result;
     }
 
Index: staticSlicer/data/testcases/output/specific/WhileIf/pdg/dot/String[]).dot
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/staticSlicer/data/testcases/output/specific/WhileIf/pdg/dot/String[]).dot b/staticSlicer/data/testcases/output/specific/WhileIf/pdg/dot/String[]).dot
new file mode 100644
--- /dev/null	(date 1689149799209)
+++ b/staticSlicer/data/testcases/output/specific/WhileIf/pdg/dot/String[]).dot	(date 1689149799209)
@@ -0,0 +1,41 @@
+digraph G {
+  0 [ label="ENTER main" ];
+  2 [ label="int n = 0;" ];
+  3 [ label="int i = 1;" ];
+  4 [ label="int sum = 0;" ];
+  5 [ label="int product = 1;" ];
+  6 [ label="i < n" ];
+  7 [ label="sum = sum + i;" ];
+  8 [ label="product = product * i;" ];
+  9 [ label="i = i + 1;" ];
+  10 [ label="System.out.println(sum);" ];
+  11 [ label="System.out.println(product);" ];
+  3 -> 6 [ style="dashed" label="[i]" ];
+  2 -> 6 [ style="dashed" label="[n]" ];
+  9 -> 6 [ style="dashed" label="[i]" ];
+  4 -> 7 [ style="dashed" label="[sum]" ];
+  3 -> 7 [ style="dashed" label="[i]" ];
+  9 -> 7 [ style="dashed" label="[i]" ];
+  7 -> 7 [ style="dashed" label="[sum]" ];
+  5 -> 8 [ style="dashed" label="[product]" ];
+  3 -> 8 [ style="dashed" label="[i]" ];
+  9 -> 8 [ style="dashed" label="[i]" ];
+  8 -> 8 [ style="dashed" label="[product]" ];
+  3 -> 9 [ style="dashed" label="[i]" ];
+  9 -> 9 [ style="dashed" label="[i]" ];
+  4 -> 10 [ style="dashed" label="[sum]" ];
+  7 -> 10 [ style="dashed" label="[sum]" ];
+  5 -> 11 [ style="dashed" label="[product]" ];
+  8 -> 11 [ style="dashed" label="[product]" ];
+  0 -> 2 [ ];
+  0 -> 3 [ ];
+  0 -> 4 [ ];
+  0 -> 5 [ ];
+  0 -> 6 [ ];
+  0 -> 10 [ ];
+  0 -> 11 [ ];
+  6 -> 7 [ ];
+  6 -> 8 [ ];
+  6 -> 9 [ ];
+  6 -> 6 [ ];
+}
Index: staticSlicer/data/testcases/output/specific/WhileIf/pdg/dot/String[])pdt.dot
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/staticSlicer/data/testcases/output/specific/WhileIf/pdg/dot/String[])pdt.dot b/staticSlicer/data/testcases/output/specific/WhileIf/pdg/dot/String[])pdt.dot
new file mode 100644
--- /dev/null	(date 1689149799578)
+++ b/staticSlicer/data/testcases/output/specific/WhileIf/pdg/dot/String[])pdt.dot	(date 1689149799578)
@@ -0,0 +1,25 @@
+digraph G {
+  0 [ label="ENTER main" ];
+  1 [ label="EXIT main" ];
+  2 [ label="int n = 0;" ];
+  3 [ label="int i = 1;" ];
+  4 [ label="int sum = 0;" ];
+  5 [ label="int product = 1;" ];
+  6 [ label="i < n" ];
+  7 [ label="sum = sum + i;" ];
+  8 [ label="product = product * i;" ];
+  9 [ label="i = i + 1;" ];
+  10 [ label="System.out.println(sum);" ];
+  11 [ label="System.out.println(product);" ];
+  9 -> 8;
+  6 -> 5;
+  4 -> 3;
+  8 -> 7;
+  3 -> 2;
+  11 -> 10;
+  6 -> 9;
+  1 -> 11;
+  10 -> 6;
+  5 -> 4;
+  1 -> 0;
+}
Index: staticSlicer/data/output/slicedCode/Slicer_Output1.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/staticSlicer/data/output/slicedCode/Slicer_Output1.java b/staticSlicer/data/output/slicedCode/Slicer_Output1.java
new file mode 100644
--- /dev/null	(date 1689143860551)
+++ b/staticSlicer/data/output/slicedCode/Slicer_Output1.java	(date 1689143860551)
@@ -0,0 +1,10 @@
+public class CFG_Test1 {
+
+    public static void main(String[] args) {
+        int a = 0;
+
+        System.out.println(a);
+    }
+
+
+}
Index: .idea/modules.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ProjectModuleManager\">\r\n    <modules>\r\n      <module fileurl=\"file://$PROJECT_DIR$/backend (1).iml\" filepath=\"$PROJECT_DIR$/backend (1).iml\" />\r\n      <module fileurl=\"file://$PROJECT_DIR$/staticSlicer/staticSlicer.iml\" filepath=\"$PROJECT_DIR$/staticSlicer/staticSlicer.iml\" />\r\n    </modules>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/modules.xml b/.idea/modules.xml
--- a/.idea/modules.xml	(revision 1ac285b88d8ebb7103d45f673d4e88ee1d5a841c)
+++ b/.idea/modules.xml	(date 1689150982519)
@@ -3,7 +3,6 @@
   <component name="ProjectModuleManager">
     <modules>
       <module fileurl="file://$PROJECT_DIR$/backend (1).iml" filepath="$PROJECT_DIR$/backend (1).iml" />
-      <module fileurl="file://$PROJECT_DIR$/staticSlicer/staticSlicer.iml" filepath="$PROJECT_DIR$/staticSlicer/staticSlicer.iml" />
     </modules>
   </component>
 </project>
\ No newline at end of file
Index: staticSlicer/data/testcases/output/specific/WhileIf/cfg/dot/String[]).dot
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/staticSlicer/data/testcases/output/specific/WhileIf/cfg/dot/String[]).dot b/staticSlicer/data/testcases/output/specific/WhileIf/cfg/dot/String[]).dot
new file mode 100644
--- /dev/null	(date 1689149886593)
+++ b/staticSlicer/data/testcases/output/specific/WhileIf/cfg/dot/String[]).dot	(date 1689149886593)
@@ -0,0 +1,26 @@
+digraph G {
+  0 [ label="ENTER main" ];
+  1 [ label="EXIT main" ];
+  2 [ label="int n = 0;" ];
+  3 [ label="int i = 1;" ];
+  4 [ label="int sum = 0;" ];
+  5 [ label="int product = 1;" ];
+  6 [ shape="diamond" label="i < n" ];
+  7 [ label="sum = sum + i;" ];
+  8 [ label="product = product * i;" ];
+  9 [ label="i = i + 1;" ];
+  10 [ label="System.out.println(sum);" ];
+  11 [ label="System.out.println(product);" ];
+  0 -> 2;
+  2 -> 3;
+  3 -> 4;
+  4 -> 5;
+  5 -> 6;
+  6 -> 7;
+  7 -> 8;
+  8 -> 9;
+  9 -> 6;
+  6 -> 10;
+  10 -> 11;
+  11 -> 1;
+}
Index: staticSlicer/data/testcases/output/specific/WhileIf/cfg/dot/String[])acfg.dot
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/staticSlicer/data/testcases/output/specific/WhileIf/cfg/dot/String[])acfg.dot b/staticSlicer/data/testcases/output/specific/WhileIf/cfg/dot/String[])acfg.dot
new file mode 100644
--- /dev/null	(date 1689149886598)
+++ b/staticSlicer/data/testcases/output/specific/WhileIf/cfg/dot/String[])acfg.dot	(date 1689149886598)
@@ -0,0 +1,27 @@
+digraph G {
+  0 [ shape="diamond" label="ENTER main" ];
+  1 [ label="EXIT main" ];
+  2 [ label="int n = 0;" ];
+  3 [ label="int i = 1;" ];
+  4 [ label="int sum = 0;" ];
+  5 [ label="int product = 1;" ];
+  6 [ shape="diamond" label="i < n" ];
+  7 [ label="sum = sum + i;" ];
+  8 [ label="product = product * i;" ];
+  9 [ label="i = i + 1;" ];
+  10 [ label="System.out.println(sum);" ];
+  11 [ label="System.out.println(product);" ];
+  0 -> 2 [ ];
+  2 -> 3 [ ];
+  3 -> 4 [ ];
+  4 -> 5 [ ];
+  5 -> 6 [ ];
+  6 -> 7 [ ];
+  7 -> 8 [ ];
+  8 -> 9 [ ];
+  9 -> 6 [ ];
+  6 -> 10 [ ];
+  10 -> 11 [ ];
+  11 -> 1 [ ];
+  0 -> 1 [ style="dashed" ];
+}
